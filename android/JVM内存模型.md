**摘要：**

　　我们都知道，Java 程序在执行前首先会被编译成字节码文件，然后再由 Java [虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)执行这些字节码文件从而使得 Java 程序得以执行。事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间，并且它们可以分为两种类型：线程共享的方法区和堆，线程私有的虚拟机栈、本地方法栈和程序计数器。在此基础上，我们探讨了在虚拟机中对象的创建和对象的访问定位等问题，并分析了 Java 虚拟机规范中异常产生的情况。

## 一. Java 虚拟机[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)模型

　　Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域可以分为两个部分：一部分是线程共享的，一部分则是线程私有的。其中，线程共享的数据区包括方法区和堆，线程私有的数据区包括虚拟机栈、本地方法栈和[程序计数器](https://so.csdn.net/so/search?q=程序计数器&spm=1001.2101.3001.7020)。如下图所示：　　　　　　　　　

**1、线程私有的数据区**

　　**线程私有的数据区** 包括 程序计数器、 虚拟机栈 和 本地方法栈 三个区域，它们的内涵分别如下：

1)、程序计数器

　　我们知道，线程是 CPU 调度的基本单位。在多线程情况下，当线程数超过 CPU 数量或 CPU 内核数量时，线程之间就要根据 时间片轮询抢夺 CPU 时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，**为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。**

　　因此，**程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指示器。**如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的字节码指令的地址；如果正在执行的是 Native 方法，则计数器的值为空。

　　程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。

2)、虚拟机栈

　　**虚拟机栈描述的是 Java 方法执行的内存模型，是线程私有的。**每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且 **每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。**其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。

　　虚拟机栈有两种异常情况：StackOverflowError 和 OutOfMemoryError。**我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出 StackOverFlowError 异常。**此外，栈的大小可以是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存 **(比如没有足够的内存为一个新创建的线程分配栈空间时)**，则抛出 OutofMemoryError 异常。下图为栈帧结构图：

## 　　　　　　　　　　　![img](https://img-blog.csdn.net/20170505082120037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



3)、本地方法栈

　　**本地方法栈与 Java 虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。**与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

**2、线程共享的数据区**

　　**线程共享的数据区** 具体包括 Java 堆 和 方法区 两个区域，它们的内涵分别如下：

1)、Java 堆

　　**Java 堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。**Java 堆是线程共享的，类的对象从中分配空间，这些对象通过 new、newarray、 anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。

　　由于 Java 堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为称为 **GC 堆**。**从内存回收的角度看，由于现在的垃圾收集器基本都采用分代收集算法，所以为了方便垃圾回收 Java 堆还可以分为 \**新生代\** 和 \**老年代\** 。**新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。刚创建的对象都放入 eden，s0 和 s1 都至少经过一次 GC 并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。更多关于 Java 堆和分代收集算法的介绍，请移步我的博文[《Java 垃圾回收机制概述》](http://blog.csdn.net/justloveyou_/article/details/71216049)。下图给出了 Java 堆的结构图：

　　　　　　　　　　　　　　

![img](https://img-blog.csdn.net/20170505083056192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



　　**注意，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。**而且，Java 堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过 - Xmx(最大堆容量) 和 -Xms(最小堆容量) 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出 OutOfMemoryError 异常。
　　 　　
(1)、TLAB (Thread Local Allocation Buffer，线程私有分配缓冲区)

　　Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB，其大小由 JVM 根据运行的情况计算而得。在 TLAB 上分配对象时不需要加锁 (相对于 CAS 配上失败重试方式)，因此 JVM 在给线程的对象分配内存时会尽量的在 TLAB 上分配，在这种情况下 JVM 中分配对象内存的性能和 C 基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。

　　在下文中我们提到，虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象 A 分配内存，指针还未修改，对象 B 又同时使用原来的指针分配内存的情况。**TLAB 的存在就是为了解决这个问题：每个线程在 Java 堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的 TLAB 上进行分配，若 TLAB 用完并分配新的 TLAB 时，再加同步锁定，这样就大大提升了对象内存分配的效率。**

2)、方法区

　　**方法区与 Java 堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 \**类信息\**、\**常量\**、\**静态变量\**、\**即时编译器编译后的代码等数据\**。**方法区通常和永久区 (Perm) 关联在一起，但永久代与方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，这样就可以用永久代 GC 来管理方法区，省去专门内存管理的工作。根据 Java 虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出 OutOfMemoryError 异常。

(1)、运行时常量池

　　**运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种 \**字面量\** 和 \**符号引用\****。其中，字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类常量：**类和接口的全限定名**、**字段的名称和描述符** 和 **方法的名称和描述符**。因为运行时常量池（Runtime Constant Pool）是方法区的一部分，那么当常量池无法再申请到内存时也会抛出 OutOfMemoryError 异常。

　　**运行时常量池相对于 Class 文件常量池的一个重要特征是具备动态性。**Java 语言并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如字符串的手动入池方法 intern()。

3)、Java 堆 与 方法区的区别

　　**Java 堆是 \**Java 代码可及的内存，是留给开发人员使用的\**；而非堆（Non-Heap）是 \**JVM 留给自己用的\**，所以方法区、JVM 内部处理或优化所需的内存 (如 JIT 编译后的代码缓存)、每个类结构 (如运行时常量池、字段和方法数据) 以及方法和构造方法的代码都在非堆内存中。**

4)、方法区的回收

　　方法区的内存回收目标主要是针对 **常量池的回收** 和 **对类型的卸载**。回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串 “abc” 已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做 “abc” 的，换句话说是没有任何 String 对象引用常量池中的 “abc” 常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个 “abc” 常量就会被系统 “请” 出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

　　判定一个常量是否是 “废弃常量” 比较简单，而要判定一个类是否是 “无用的类” 的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；

- 加载该类的 ClassLoader 已经被回收；

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  　　虚拟机可以对满足上述 3 个条件的无用类进行回收 (卸载)，这里说的仅仅是 “可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib 等 bytecode 框架的场景，以及动态生成 JSP 和 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。

## 二. Java 对象在虚拟机中的创建与访问定位

　　Java 是一门面向对象的编程语言，在 Java 程序运行过程中无时无刻都有对象被创建和使用。在此，我们以最流行的 HotSpot 虚拟机以及常用的内存区域 Java 堆为例来探讨在虚拟机中对象的创建和对象的访问等问题。

**1、对象在虚拟机中的创建过程**

　　(1). 检查虚拟机是否加载了所要 new 的类，若没加载，则首先执行相应的类加载过程。虚拟机遇到 new 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个引用代表的类是否已经被加载、解析和初始化过。

　　(2). 在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。一般来说，**根据 Java 堆中内存是否绝对规整，**内存的分配有两种方式：

- **指针碰撞：****如果 Java 堆中内存绝对规整，**所有用过的内存放在一边，空闲内存放在另一边，中间一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相同的距离。
- **空闲列表：****如果 Java 堆中内存并不规整，**那么虚拟机就需要维护一个列表，记录哪些内存块是可用的，以便在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

　　除了如何划分可用空间之外，还需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象 A 分配内存，指针还未修改，对象 B 又同时使用原来的指针分配内存的情况。解决这个问题有两种方案：

- **对分配内存空间的动作进行同步处理：**采用 CAS + 失败重试的方式保证更新操作的原子性；
- **把内存分配的动作按照线程划分的不同的空间中：**每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的 TLAB 上分配，如果 TLAB 用完并分配新的 TLAB 时，再加同步锁定。

　　(3). 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。如果使用 TLAB，也可以提前到 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

　　(4). 在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象的创建才刚刚开始，此时会执行 < init > 方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。

**2、对象在虚拟机中的访问定位**

　　**创建对象是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。**在虚拟机规范中，reference 类型中只规定了一个指向对象的引用，并没有定义这个引用使用什么方式去定位、访问堆中的对象的具体位置。目前的主流的访问方式有使用句柄访问和直接指针访问两种。

- **句柄访问**：Java 堆中会划分出一块内存作为句柄池，栈中的 reference 指向对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。

  　　　　　　　　　　

  ![img](https://img-blog.csdn.net/20170505200615074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **直接指针访问**：reference 中存储的就是对象地址。

  　　　　　　　　　　

  ![img](https://img-blog.csdn.net/20170505200629589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

  

　　总的来说，这两种对象访问定位方式各有千秋。**使用句柄访问的最大好处就是 reference 中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference 本身不需要修改；****而使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销。**

## 三. 内存异常产生情况分析

1、Java 堆溢出 (OOM)

　　Java 堆用于存储对象的实例，只要不断地创建对象，并且保证 GC roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。如下所示，

```
public class Test {

public static void main(String[] args){
        List list=new ArrayList();   // 持有“大对象”的引用，防止垃圾回收
        while(true){
            int[] tmp = new int[10000000];  // 不断创建“大对象”
            list.add(tmp);
        }
    }
}
```

![img](https://img-blog.csdn.net/20170515152050847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

　　要解决这个异常，一般先通过内存映像分析工具对堆转储快照分析，确定内存的对象是否是必要的，即判断是 **内存泄露** 还是 **内存溢出**。如果是内存泄露，可以进一步通过工具查看泄露对象到 GC Roots 的引用链，比较准确地定位出泄露代码的位置。如果是内存溢出，可以调大虚拟机堆参数，或者从代码上检查是否存在某些对象生命周期过长的情况。

2、虚拟机栈和本地方法栈溢出 (SOF/OOM)

**(1). SOF**

　　**如果线程请求的栈深度大于虚拟机栈允许的最大深度，将抛出 StackOverflowError 异常。**我们知道，每当 Java 程序启动一个新的线程时，Java 虚拟机会为它分配一个栈，并且 Java 虚拟机栈以栈帧为单位保持线程运行状态。每当线程调用一个方法时，JVM 就压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 那么可以想象，如果方法的嵌套调用层次太多，比如递归调用，随着 Java 虚拟机栈中的栈帧的不断增多，最终很可能会导致这个线程的栈中的所有栈帧的大小的总和大于 - Xss 设置的值，从而产生 StackOverflowError 溢出异常。看下面的栗子：

```
public class Test {

    public static void main(String[] args) {
          method();
    }

    // 递归调用导致 StackOverflowError
    public static void method(){
        method();
    }
}
```

　　　　　　　　　　　　　　

![img](https://img-blog.csdn.net/20170515151510655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



　　上面的 SOF 异常就是由递归引起的，具体而言就是因为 method() 方法中没有递归终止条件，从而使得该方法不断递归调用、不断创建栈帧导致的。

**(2). OOM**

　　**如果虚拟机在拓展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。**在虚拟机栈和本地方法栈发生 OOM 异常场景如下：**当 Java 程序启动一个新线程时，若没有足够的空间为该线程分配 Java 栈 (一个线程 Java 栈的大小由 - Xss 设置决定)，JVM 将抛出 OutOfMemoryError 异常。**

3、方法区和运行时常量池溢出 (OOM)

　　**运行时常量池溢出的情况：** String.intern() 是一个 native 方法，**在 JDK1.6 及之前的版本中，**它的作用是：如果字符串常量池中已经包含一个等于此 String 对象的字符串，则返回代表池中这个字符串的 String 对象，否则将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。由于常量池分配在永久代中，如果不断地使用 intern 方法手动入池字符串，则会抛出 OutOfMemoryError 异常。**但在 JDK1.7 及其以后的版本中，对 intern（）方法的实现作了进一步改进，其不会再复制实例到常量池中，而仅仅是在常量池中记录首次出现的实例的引用。**看下面的例子（在 JDK1.7 中运行），

```
public class Test {  
    public static void main(String[] args) {  

        String str1 = new StringBuilder("计算机").append("软件").toString();
        System.out.println(str1.intern() == str1);

        String str2 = new StringBuilder("java").toString();
        System.out.println(str2.intern() == str2);
    }/* Output: 
        true
        false
     *///:~  
```

　　为什么第一个返回 true，而第二个返回 false 呢？因为在 JDK1.7 中，intern（）方法的实现不会再复制实例，只是在常量池中记录 **首次** 出现的实例的引用，因此 str1.intern()和 str1 指向的是同一个字符串，所以返回 true。同一个引用。对于 “java” 这个字符串，由于在执行 StringBuilder.toString() 之前已经出现过，所以字符串常量池中在 new StringBuilder(“java”).toString()之前已经有它的引用了，不符合首次出现的原则，因此返回 fasle。有人可能心里可能就要嘀咕了，为啥第二个不符合首次出现的原则，而第一个就符合首次出现的原则呢？ 实际上，

```
String str2 = new StringBuilder("java").toString();
```

等价于：

```
String s1 = "java";
StringBuilder sb = new StringBuilder(s1);
String str2 = sb.toString();

// StringBuilder 的 toString()方法
public String toString() {
        // Create a copy, don't share the array
        return new String(value, 0, count);
}
```

　　由上面代码可知，字符串”java” 早就出现了，因此不符合首次出现的原则，返回 false。同理，“计算机软件” 这个字符串在 new StringBuilder(“计算机”).append(“软件”).toString() 之前从未出现过，因此符合首次出现的原则，返回 true。

　　**方法区溢出的情况：**一个类要被垃圾回收器回收掉，判断条件是比较苛刻的。 在经常动态产生大量 Class 的应用中，需要特别注意类的回收状况，比如动态语言、大量 JSP 或者动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）、基于 OSGi 的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。
åœ¨ç¬¬å…­ç¯‡ä¸­æˆ‘ä»¬çŸ¥é“äº† `Widget`ã€`Element`ã€`RenderObject` ä¸‰è€…ä¹‹é—´çš„å…³ç³»ï¼Œå…¶ä¸­æˆ‘ä»¬æœ€ä¸ºç†ŸçŸ¥çš„ `Widget` ï¼Œä½œä¸º â€œé…ç½®æ–‡ä»¶â€ çš„å­˜åœ¨ï¼Œåœ¨ Flutter ä¸­å®ƒçš„åŠŸèƒ½éƒ½æ˜¯æ¯”è¾ƒå•ä¸€çš„ï¼Œå±äº *â€œé¢—ç²’åº¦æ¯”è¾ƒç»†çš„å­˜åœ¨â€* ï¼Œå†™ä»£ç æ—¶å°±åƒæ‹¼ä¹é«˜ â€œç§¯æœ¨â€ï¼Œé‚£è¿™â€œç§¯æœ¨â€ ç©¶ç«Ÿæ€ä¹ˆæ‹¼çš„ï¼Ÿä¸‹é¢å°± **æ·±å…¥** å»æŒ–æŒ–æœ‰æ„æ€çš„ä¸œè¥¿å§ã€‚(ï¿£â–½ï¿£)

## ä¸€ã€å•å­å…ƒç´ å¸ƒå±€

åœ¨ Flutter å•ä¸ªå­å…ƒç´ çš„å¸ƒå±€ Widget ä¸­ï¼Œ**`Container`** æ— ç–‘æ˜¯è¢«ç”¨çš„æœ€å¹¿æ³›çš„ï¼Œå› ä¸ºå®ƒåœ¨ â€œåŠŸèƒ½â€ ä¸Šå¹¶ä¸ä¼šå¦‚ `Padding` ç­‰ Widget é‚£æ ·åŠŸèƒ½å•ä¸€ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

ç©¶å…¶åŸå› ï¼Œä»ä¸‹å›¾æºç å¯ä»¥çœ‹å‡ºï¼Œ**`Container`** å…¶å®ä¹Ÿåªæ˜¯æŠŠå…¶ä»– â€œå•ä¸€â€ çš„ Widget åšäº†äºŒæ¬¡å°è£…ï¼Œç„¶åé€šè¿‡é…ç½®æ¥è¾¾åˆ° â€œå¤šåŠŸèƒ½çš„æ•ˆæœâ€ è€Œå·²ã€‚

```dart
@override
  Widget build(BuildContext context) {
    Widget? current = child;

    if (child == null && (constraints == null || !constraints!.isTight)) {
      current = LimitedBox(
        maxWidth: 0.0,
        maxHeight: 0.0,
        child: ConstrainedBox(constraints: const BoxConstraints.expand()),
      );
    }

    if (alignment != null)
      current = Align(alignment: alignment!, child: current);

    final EdgeInsetsGeometry? effectivePadding = _paddingIncludingDecoration;
    if (effectivePadding != null)
      current = Padding(padding: effectivePadding, child: current);

    if (color != null)
      current = ColoredBox(color: color!, child: current);

    if (clipBehavior != Clip.none) {
      assert(decoration != null);
      current = ClipPath(
        clipper: _DecorationClipper(
          textDirection: Directionality.maybeOf(context),
          decoration: decoration!,
        ),
        clipBehavior: clipBehavior,
        child: current,
      );
    }

    if (decoration != null)
      current = DecoratedBox(decoration: decoration!, child: current);

    if (foregroundDecoration != null) {
      current = DecoratedBox(
        decoration: foregroundDecoration!,
        position: DecorationPosition.foreground,
        child: current,
      );
    }

    if (constraints != null)
      current = ConstrainedBox(constraints: constraints!, child: current);

    if (margin != null)
      current = Padding(padding: margin!, child: current);

    if (transform != null)
      current = Transform(transform: transform!, alignment: transformAlignment, child: current);

    return current!;
  }
```

æ¥ç€æˆ‘ä»¬å…ˆçœ‹ `ConstrainedBox` æºç ï¼Œä»ä¸‹å›¾æºç å¯ä»¥çœ‹å‡ºï¼Œå®ƒæ˜¯ç»§æ‰¿äº† `SingleChildRenderObjectWidget`ï¼Œå…³é”®æ˜¯ override äº† `createRenderObject` æ–¹æ³•ï¼Œè¿”å›äº† **`RenderConstrainedBox`** ã€‚

è¿™é‡Œä½“ç°äº†ç¬¬å…­ç¯‡ä¸­çš„ Widget ä¸ RenderObject çš„å…³ç³»

æ˜¯çš„ï¼Œ**`RenderConstrainedBox`** å°±æ˜¯ç»§æ‰¿è‡ª `RenderBox`ï¼Œä»è€Œå®ç°`RenderObject` çš„å¸ƒå±€ï¼Œè¿™é‡Œæˆ‘ä»¬å¾—åˆ°äº†å®ƒä»¬çš„å…³ç³»å¦‚ä¸‹ ï¼š

| Widget         | RenderObject         |
| -------------- | -------------------- |
| ConstrainedBox | RenderConstrainedBox |

```dart
class ConstrainedBox extends SingleChildRenderObjectWidget {
  /// Creates a widget that imposes additional constraints on its child.
  ///
  /// The [constraints] argument must not be null.
  ConstrainedBox({
    Key? key,
    required this.constraints,
    Widget? child,
  }) : assert(constraints != null),
       assert(constraints.debugAssertIsValid()),
       super(key: key, child: child);

  /// The additional constraints to impose on the child.
  final BoxConstraints constraints;

  @override
  RenderConstrainedBox createRenderObject(BuildContext context) {
    return RenderConstrainedBox(additionalConstraints: constraints);
  }

  @override
  void updateRenderObject(BuildContext context, RenderConstrainedBox renderObject) {
    renderObject.additionalConstraints = constraints;
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<BoxConstraints>('constraints', constraints, showName: false));
  }
}
```

ç„¶åæˆ‘ä»¬ç»§ç»­å¯¹å…¶ä»–æ¯ä¸ª Widget è¿›è¡Œè§‚å¯Ÿï¼Œå¯ä»¥çœ‹åˆ°å®ƒä»¬ä¹Ÿéƒ½æ˜¯ç»§æ‰¿`SingleChildRenderObjectWidget` ï¼Œè€Œ â€œç®€å•æ¥è¯´â€ å®ƒä»¬ä¸åŒçš„åœ°æ–¹å°±æ˜¯ `RenderObject` çš„å®ç°äº†ï¼š

| Widget    | RenderBox ï¼ˆRenderObjectï¼‰ |
| --------- | -------------------------- |
| Align     | RenderPositionedBox        |
| Padding   | RenderPadding              |
| Transform | RenderTransform            |
| Offstage  | RenderOffstage             |

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ€»ç»“ï¼š**çœŸæ­£çš„å¸ƒå±€å’Œå¤§å°è®¡ç®—ç­‰è¡Œä¸ºï¼Œéƒ½æ˜¯åœ¨ `RenderBox` ä¸Šå»å®ç°çš„ã€‚** ä¸åŒçš„ Widget é€šè¿‡å„è‡ªçš„ `RenderBox` å®ç°äº† â€œå·®å¼‚åŒ–â€ çš„å¸ƒå±€æ•ˆæœã€‚**æ‰€ä»¥æ‰¾æ¯ä¸ª Widget çš„å®ç°ï¼Œæ‰¾å®ƒçš„ `RenderBox` å®ç°å°±å¯ä»¥äº†ã€‚**ï¼ˆå½“ç„¶ï¼Œå¦å¤–è¿˜æœ‰ `RenderSliver`ï¼Œè¿™é‡Œæš‚æ—¶ä¸è®¨è®ºï¼‰

è¿™é‡Œæˆ‘ä»¬é€šè¿‡ **`Offstage`** è¿™ä¸ª Widget å°ç»“ä¸‹ï¼Œ**`Offstage`** è¿™ä¸ª Widget æ˜¯é€šè¿‡ `offstage` æ ‡å¿—æ§åˆ¶ **child** æ˜¯å¦æ˜¾ç¤ºçš„æ•ˆæœï¼ŒåŒæ ·çš„å®ƒä¹Ÿæœ‰ä¸€ä¸ª `RenderOffstage` ï¼Œå¦‚ä¸‹å›¾ï¼Œé€šè¿‡ `RenderOffstage` çš„æºç æˆ‘ä»¬å¯ä»¥ â€œçœŸå®â€ çœ‹åˆ° `offstage` æ ‡å¿—ä½çš„ä½œç”¨ï¼š

```dart
class RenderOffstage extends RenderProxyBox {
  /// Creates an offstage render object.
  RenderOffstage({
    bool offstage = true,
    RenderBox? child,
  }) : assert(offstage != null),
       _offstage = offstage,
       super(child);

  /// Whether the child is hidden from the rest of the tree.
  ///
  /// If true, the child is laid out as if it was in the tree, but without
  /// painting anything, without making the child available for hit testing, and
  /// without taking any room in the parent.
  ///
  /// If false, the child is included in the tree as normal.
  bool get offstage => _offstage;
  bool _offstage;
  set offstage(bool value) {
    assert(value != null);
    if (value == _offstage)
      return;
    _offstage = value;
    markNeedsLayoutForSizedByParentChange();
  }

  @override
  double computeMinIntrinsicWidth(double height) {
    if (offstage)
      return 0.0;
    return super.computeMinIntrinsicWidth(height);
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    if (offstage)
      return 0.0;
    return super.computeMaxIntrinsicWidth(height);
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    if (offstage)
      return 0.0;
    return super.computeMinIntrinsicHeight(width);
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    if (offstage)
      return 0.0;
    return super.computeMaxIntrinsicHeight(width);
  }

  @override
  double? computeDistanceToActualBaseline(TextBaseline baseline) {
    if (offstage)
      return null;
    return super.computeDistanceToActualBaseline(baseline);
  }

  @override
  bool get sizedByParent => offstage;

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    if (offstage) {
      return constraints.smallest;
    }
    return super.computeDryLayout(constraints);
  }


  @override
  void performResize() {
    assert(offstage);
    super.performResize();
  }

  @override
  void performLayout() {
    if (offstage) {
      child?.layout(constraints);
    } else {
      super.performLayout();
    }
  }

  @override
  bool hitTest(BoxHitTestResult result, { required Offset position }) {
    return !offstage && super.hitTest(result, position: position);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    if (offstage)
      return;
    super.paint(context, offset);
  }

  @override
  void visitChildrenForSemantics(RenderObjectVisitor visitor) {
    if (offstage)
      return;
    super.visitChildrenForSemantics(visitor);
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty<bool>('offstage', offstage));
  }

  @override
  List<DiagnosticsNode> debugDescribeChildren() {
    if (child == null)
      return <DiagnosticsNode>[];
    return <DiagnosticsNode>[
      child!.toDiagnosticsNode(
        name: 'child',
        style: offstage ? DiagnosticsTreeStyle.offstage : DiagnosticsTreeStyle.sparse,
      ),
    ];
  }
}

```

æ‰€ä»¥å¤§éƒ¨åˆ†æ—¶å€™ï¼Œæˆ‘ä»¬çš„ Widget éƒ½æ˜¯é€šè¿‡å®ç° `RenderBox` å®ç°å¸ƒå±€çš„ ï¼Œ**é‚£æˆ‘ä»¬å¯ä¸å¯æŠ›èµ· Widget ç›´æ¥ç”¨ `RenderBox`å‘¢ï¼Ÿç­”æ¡ˆæ˜æ˜¾æ˜¯å¯ä»¥çš„ï¼Œå¦‚æœä½ é—²çš„ğŸ¥šç–¼çš„è¯ï¼**

Flutter å®˜æ–¹ä¸ºäº†æ²»ç–—æˆ‘ä»¬ â€œğŸ¥šç–¼â€ï¼Œæä¾›äº†ä¸€ä¸ªå« **`CustomSingleChildLayout`** çš„ç±»ï¼Œå®ƒæŠ½è±¡äº†ä¸€ä¸ªå« `SingleChildLayoutDelegate` çš„å¯¹è±¡ï¼Œè®©ä½ å¯ä»¥æ›´æ–¹ä¾¿çš„æ“ä½œ `RenderBox` æ¥è¾¾åˆ°è‡ªå®šä¹‰çš„æ•ˆæœã€‚

```dart
class CustomSingleChildLayout extends SingleChildRenderObjectWidget {
  /// Creates a custom single child layout.
  ///
  /// The [delegate] argument must not be null.
  const CustomSingleChildLayout({
    Key? key,
    required this.delegate,
    Widget? child,
  }) : assert(delegate != null),
       super(key: key, child: child);

  /// The delegate that controls the layout of the child.
  final SingleChildLayoutDelegate delegate;

  @override
  RenderCustomSingleChildLayoutBox createRenderObject(BuildContext context) {
    return RenderCustomSingleChildLayoutBox(delegate: delegate);
  }

  @override
  void updateRenderObject(BuildContext context, RenderCustomSingleChildLayoutBox renderObject) {
    renderObject.delegate = delegate;
  }
}
```

å¦‚ä¸‹å›¾ä¸‰å¼ æºç æ‰€ç¤ºï¼Œ`SingleChildLayoutDelegate` çš„å¯¹è±¡æä¾›ä»¥ä¸‹æ¥å£ï¼Œå¹¶ä¸”æ¥å£ **å‰ä¸‰ä¸ª** æ˜¯æŒ‰ç…§é¡ºåºè¢«è°ƒç”¨çš„ï¼Œé€šè¿‡å®ç°è¿™ä¸ªæ¥å£ï¼Œä½ å°±å¯ä»¥è½»æ¾çš„æ§åˆ¶ RenderBox çš„ *å¸ƒå±€ä½ç½®ã€å¤§å°* ç­‰ã€‚

```dart
abstract class SingleChildLayoutDelegate {
  /// Creates a layout delegate.
  ///
  /// The layout will update whenever [relayout] notifies its listeners.
  const SingleChildLayoutDelegate({ Listenable? relayout }) : _relayout = relayout;

  final Listenable? _relayout;

  /// The size of this object given the incoming constraints.
  ///
  /// Defaults to the biggest size that satisfies the given constraints.
  Size getSize(BoxConstraints constraints) => constraints.biggest;

  /// The constraints for the child given the incoming constraints.
  ///
  /// During layout, the child is given the layout constraints returned by this
  /// function. The child is required to pick a size for itself that satisfies
  /// these constraints.
  ///
  /// Defaults to the given constraints.
  BoxConstraints getConstraintsForChild(BoxConstraints constraints) => constraints;

  /// The position where the child should be placed.
  ///
  /// The `size` argument is the size of the parent, which might be different
  /// from the value returned by [getSize] if that size doesn't satisfy the
  /// constraints passed to [getSize]. The `childSize` argument is the size of
  /// the child, which will satisfy the constraints returned by
  /// [getConstraintsForChild].
  ///
  /// Defaults to positioning the child in the upper left corner of the parent.
  Offset getPositionForChild(Size size, Size childSize) => Offset.zero;

  /// Called whenever a new instance of the custom layout delegate class is
  /// provided to the [RenderCustomSingleChildLayoutBox] object, or any time
  /// that a new [CustomSingleChildLayout] object is created with a new instance
  /// of the custom layout delegate class (which amounts to the same thing,
  /// because the latter is implemented in terms of the former).
  ///
  /// If the new instance represents different information than the old
  /// instance, then the method should return true, otherwise it should return
  /// false.
  ///
  /// If the method returns false, then the [getSize],
  /// [getConstraintsForChild], and [getPositionForChild] calls might be
  /// optimized away.
  ///
  /// It's possible that the layout methods will get called even if
  /// [shouldRelayout] returns false (e.g. if an ancestor changed its layout).
  /// It's also possible that the layout method will get called
  /// without [shouldRelayout] being called at all (e.g. if the parent changes
  /// size).
  bool shouldRelayout(covariant SingleChildLayoutDelegate oldDelegate);
}
```

```dart
Size _getSize(BoxConstraints constraints) {
    return constraints.constrain(_delegate.getSize(constraints));
  }

  // TODO(ianh): It's a bit dubious to be using the getSize function from the delegate to
  // figure out the intrinsic dimensions. We really should either not support intrinsics,
  // or we should expose intrinsic delegate callbacks and throw if they're not implemented.

  @override
  double computeMinIntrinsicWidth(double height) {
    final double width = _getSize(BoxConstraints.tightForFinite(height: height)).width;
    if (width.isFinite)
      return width;
    return 0.0;
  }

  @override
  double computeMaxIntrinsicWidth(double height) {
    final double width = _getSize(BoxConstraints.tightForFinite(height: height)).width;
    if (width.isFinite)
      return width;
    return 0.0;
  }

  @override
  double computeMinIntrinsicHeight(double width) {
    final double height = _getSize(BoxConstraints.tightForFinite(width: width)).height;
    if (height.isFinite)
      return height;
    return 0.0;
  }

  @override
  double computeMaxIntrinsicHeight(double width) {
    final double height = _getSize(BoxConstraints.tightForFinite(width: width)).height;
    if (height.isFinite)
      return height;
    return 0.0;
  }

  @override
  Size computeDryLayout(BoxConstraints constraints) {
    return _getSize(constraints);
  }

  @override
  void performLayout() {
    size = _getSize(constraints);
    if (child != null) {
      final BoxConstraints childConstraints = delegate.getConstraintsForChild(constraints);
      assert(childConstraints.debugAssertIsValid(isAppliedConstraint: true));
      child!.layout(childConstraints, parentUsesSize: !childConstraints.isTight);
      final BoxParentData childParentData = child!.parentData! as BoxParentData;
      childParentData.offset = delegate.getPositionForChild(size, childConstraints.isTight ? childConstraints.smallest : child!.size);
    }
  }
```



## äºŒã€å¤šå­å…ƒç´ å¸ƒå±€

äº‹å®ä¸Š â€œå¤šå­å…ƒç´ å¸ƒå±€â€ å’Œå•å­å…ƒç´ ç±»ä¼¼ï¼Œé€šè¿‡ â€œä¸¾ä¸€åä¸‰â€ æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“å®ƒä»¬çš„å…³ç³»äº†ï¼Œæ¯”å¦‚ï¼š

- `Row`ã€`Colum` éƒ½ç»§æ‰¿äº† `Flex`ï¼Œè€Œ Flex ç»§æ‰¿äº†`MultiChildRenderObjectWidget` å¹¶é€šè¿‡ `RenderFlex` åˆ›å»ºäº† `RenderBox`ï¼›
- `Stack` åŒæ ·ç»§æ‰¿ `MultiChildRenderObjectWidget` å¹¶é€šè¿‡ `RenderStack` åˆ›å»ºäº† `RenderBox`ï¼›

| Widget         | RenderBox ï¼ˆRenderObjectï¼‰ |
| -------------- | -------------------------- |
| Row/Colum/Flex | RenderFlex                 |
| Stack          | RenderStack                |
| Flow           | RenderFlow                 |
| Wrap           | RenderWrap                 |

åŒæ · â€œå¤šå­å…ƒç´ å¸ƒå±€â€ ä¹Ÿæä¾›äº† `CustomMultiChildLayout` å’Œ `MultiChildLayoutDelegate` æ»¡è¶³ä½ çš„ â€œğŸ¥šç–¼â€ éœ€æ±‚ã€‚

## ä¸‰ã€å¤šå­å…ƒç´ æ»‘åŠ¨å¸ƒå±€

æ»‘åŠ¨å¸ƒå±€ä½œä¸º â€œå¤šå­å…ƒç´ å¸ƒå±€â€ çš„å¦ä¸€ä¸ªåˆ†æ”¯ï¼Œå¦‚ `ListView` ã€`GridView`ã€`Pageview` ï¼Œå®ƒä»¬åœ¨å®ç°ä¸Šè¦å¤æ‚çš„å¤šï¼Œä»ä¸‹å›¾ä¸€ä¸ªçš„æµç¨‹ä¸Šæˆ‘ä»¬å¤§è‡´å¯ä»¥çŸ¥é“å®ƒä»¬çš„å…³ç³»ï¼š



![img](http://img.cdn.guoshuyu.cn/20190604_Flutter-7/image8)



ç”±ä¸Šå›¾æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œæµç¨‹æœ€ç»ˆå›äº§ç”Ÿä¸¤ä¸ª *RenderObject* ï¼š

- `RenderSliver` ï¼š*Base class for the render objects that implement scroll effects in viewports.*
- `RenderViewport` ï¼š*A render object that is bigger on the inside.*

å¹¶ä¸”ä» `RenderViewport`çš„è¯´æ˜æˆ‘ä»¬çŸ¥é“ï¼Œ`RenderViewport`å†…éƒ¨æ˜¯ä¸èƒ½ç›´æ¥æ”¾ç½® `RenderBox`ï¼Œéœ€è¦é€šè¿‡ `RenderSliver` å¤§å®¶æ—æ¥å®Œæˆå¸ƒå±€ã€‚è€Œä»æºç å¯çŸ¥ï¼š**`RenderViewport` å¯¹åº”çš„ Widget `Viewport` å°±æ˜¯ä¸€ä¸ª `MultiChildRenderObjectWidget`ã€‚** ï¼ˆä½ çœ‹ï¼Œåˆå›åˆ° `MultiChildRenderObjectWidget` äº†å§ã€‚ï¼‰

å†ç¨å¾®è¯´ä¸‹ä¸Šå›¾çš„æµç¨‹ï¼š

- `ListView`ã€`Pageview`ã€`GridView` ç­‰éƒ½æ˜¯é€šè¿‡ `Scrollable` ã€ `ViewPort`ã€`Sliver`å¤§å®¶æ—å®ç°çš„æ•ˆæœã€‚è¿™é‡Œç®€å•ä¸è§„èŒƒæè¿°å°±æ˜¯ï¼š*ä¸€ä¸ª â€œå¯æ»‘åŠ¨â€ çš„æ§ä»¶ï¼ŒåµŒå¥—äº†ä¸€ä¸ª â€œè§†è§‰çª—å£â€ï¼Œç„¶åå†…éƒ¨é€šè¿‡â€œç¢ç‰‡â€ å±•ç¤º children* ã€‚

- ä¸åŒçš„æ˜¯ `PageView` æ²¡æœ‰ç»§æ‰¿ `SrollView`ï¼Œè€Œæ˜¯ç›´æ¥é€šè¿‡ `NotificationListener` å’Œ `ScrollNotification` åµŒå¥—å®ç°ã€‚

  æ³¨æ„ `TabBarView` å†…éƒ¨å°±æ˜¯ï¼š`NotificationListener` + `PageView`

æ˜¯ä¸æ˜¯è§‰å¾—å°‘äº†ä»€ä¹ˆï¼Ÿå“ˆå“ˆå“ˆï¼Œæœ‰çš„æœ‰çš„ï¼Œå®˜æ–¹åŒæ ·æä¾›äº†è§£å†³ â€œğŸ¥šç–¼â€ çš„è‡ªå®šä¹‰æ»‘åŠ¨ **`CustomScrollView`** ï¼Œå®ƒç»§æ‰¿äº† `ScrollView`ï¼Œå¯é€šè¿‡ slivers å‚æ•°å®ç°å¸ƒå±€ï¼Œè¿™äº› `slivers` æœ€ç»ˆå›é€šè¿‡ `Scrollable` çš„ `buildViewport` æ·»åŠ åˆ° `ViewPort` ä¸­ï¼Œå¦‚ä¸‹ä»£ç æ‰€ç¤ºï¼š

```dart
CustomScrollView(
  slivers: <Widget>[
    const SliverAppBar(
      pinned: true,
      expandedHeight: 250.0,
      flexibleSpace: FlexibleSpaceBar(
        title: Text('Demo'),
      ),
    ),
    SliverGrid(
      gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
        maxCrossAxisExtent: 200.0,
        mainAxisSpacing: 10.0,
        crossAxisSpacing: 10.0,
        childAspectRatio: 4.0,
      ),
      delegate: SliverChildBuilderDelegate(
        (BuildContext context, int index) {
          return Container(
            alignment: Alignment.center,
            color: Colors.teal[100 * (index % 9)],
            child: Text('grid item $index'),
          );
        },
        childCount: 20,
      ),
    ),
    SliverFixedExtentList(
      itemExtent: 50.0,
      delegate: SliverChildBuilderDelegate(
        (BuildContext context, int index) {
          return Container(
            alignment: Alignment.center,
            color: Colors.lightBlue[100 * (index % 9)],
            child: Text('list item $index'),
          );
        },
      ),
    ),
  ],
)
```



